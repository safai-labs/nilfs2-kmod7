From: Vyacheslav Dubeyko <slava@xxxxxxxxxxx>
Subject: [RFC][STEP 1][PATCH 4/4] nilfs-utils: nilfs-tune: implement functionality of xafile initialization

This patch implements functionality of request xafile creation
on existed NILFS2 volume by means of nilfs-tune utility.

The nilfs-tune utility simply modify superblock of such volume by
means of setting NILFS_FEATURE_COMPAT_INIT_XAFILE in
s_feature_compat field of superblock. Then, file system driver
creates xafile in the case of presence above-mentioned flag
(NILFS_FEATURE_COMPAT_INIT_XAFILE).

Signed-off-by: Vyacheslav Dubeyko <slava@xxxxxxxxxxx>
CC: Ryusuke Konishi <konishi.ryusuke@xxxxxxxxxxxxx>
---
 man/nilfs-tune.8             |    9 +++++++++
 sbin/nilfs-tune/nilfs-tune.c |   20 ++++++++++++++++++--
 2 files changed, 27 insertions(+), 2 deletions(-)

diff --git a/man/nilfs-tune.8 b/man/nilfs-tune.8
index 47dc1b3..e0ed198 100644
--- a/man/nilfs-tune.8
+++ b/man/nilfs-tune.8
@@ -52,6 +52,15 @@ Enable block count per checkpoint.
 After setting this option, fsck should be run on the filesystem to
 make the counts right, but no fsck tool is available yet, sorry.
 .RE
+.RS
+.TP
+.B xafile_init
+Enable xafile creation (if it doesn't exist).
+After setting this option, superblock will keep flag that it requests
+xafile creation. Creation request will fail if a NILFS2 volume contains
+xafile yet. The xafile will be created during nearest operation of
+segment creation.
+.RE
 .TP
 .B \-U \fIUUID\fP
 Set the universally unique identifier (UUID) of the file system to UUID.
diff --git a/sbin/nilfs-tune/nilfs-tune.c b/sbin/nilfs-tune/nilfs-tune.c
index 0698649..bc70681 100644
--- a/sbin/nilfs-tune/nilfs-tune.c
+++ b/sbin/nilfs-tune/nilfs-tune.c
@@ -84,7 +84,7 @@ static void nilfs_tune_usage(void)
 
 const static __u64 ok_features[NILFS_MAX_FEATURE_TYPES] = {
 	/* Compat */
-	0,
+	NILFS_FEATURE_COMPAT_INIT_XAFILE,
 	/* Read-only compat */
 	NILFS_FEATURE_COMPAT_RO_BLOCK_COUNT,
 	/* Incompat */
@@ -93,7 +93,7 @@ const static __u64 ok_features[NILFS_MAX_FEATURE_TYPES] = {
 
 const static __u64 clear_ok_features[NILFS_MAX_FEATURE_TYPES] = {
 	/* Compat */
-	0,
+	NILFS_FEATURE_COMPAT_INIT_XAFILE,
 	/* Read-only compat */
 	NILFS_FEATURE_COMPAT_RO_BLOCK_COUNT,
 	/* Incompat */
@@ -454,6 +454,10 @@ static void show_nilfs_sb(struct nilfs_super_block *sbp)
 	printf("CRC check data size:\t  0x%08x\n", le32_to_cpu(sbp->s_bytes));
 }
 
+#define NILFS_HAS_XAFILE(features) \
+	(((__u64 *)features)[NILFS_FEATURE_TYPE_COMPAT_RO] & \
+	 NILFS_FEATURE_COMPAT_RO_XAFILE)
+
 static int update_feature_set(struct nilfs_super_block *sbp,
 			      struct nilfs_tune_options *opts)
 {
@@ -487,6 +491,18 @@ static int update_feature_set(struct nilfs_super_block *sbp,
 				nilfs_feature2string(bad_type, bad_mask));
 		}
 	} else {
+		if ((features[NILFS_FEATURE_TYPE_COMPAT] &
+		     NILFS_FEATURE_COMPAT_INIT_XAFILE) &&
+		    (features[NILFS_FEATURE_TYPE_COMPAT_RO] &
+		     NILFS_FEATURE_COMPAT_RO_XAFILE)) {
+			fprintf(stderr,
+				"feature %s is not allowed to be set\n",
+				nilfs_feature2string(NILFS_FEATURE_TYPE_COMPAT,
+					NILFS_FEATURE_COMPAT_INIT_XAFILE));
+			ret = -1;
+			return ret;
+		}
+
 		sbp->s_feature_compat =
 			cpu_to_le64(features[NILFS_FEATURE_TYPE_COMPAT]);
 		sbp->s_feature_compat_ro =
-- 
1.7.9.5
